---
title: 多线程概述
date: 2022-05-20 21:58:10
tags:
    多线程
categories:
    C#
---

# 多线程概述

提示：多线程的学习是一系列内容

方式：概述 ➡原理➡多线程新特性的学习（实现形式上）➡根据需要综合的筛选多线程的方式写出不同的程序

## 为什么要使用多线程？

我们常见的开发是单线程程序编程，尤其是单核时代，虽然我们能够写多线程程序，但是效率并没有真正的提升。？

因为单线程计算机每个时间片只能执行一个线程

多核CPU时代：不仅要真正的多线程，还要发挥硬件CPU的作用。

## 多线程如何实现

1. 基于委托异步实现编程。因为这个是基于委托实现的，我们知道委托这个大哥很有用
2. Thread
3. ThreadPool（线程池）
4. Task（4.0时代提出的，也是后面我们应用的重点）
5. TaskFactory（类似于线程池）
6. Parallel（并行编程）

### 1、基于委托异步实现编程➡Demo

#### .Net 5及其一下版本

```c#
private static Random random = new Random();

//定义一个任务，基于委托实现求一个数的平方
private Func<int, int> Operation = (num) =>
{
    Thread.Sleep(random.Next(5) * 1000);
    return num * num;
};
//使用时被调用方法⬇
public void CeShi(){
    for (int i = 1; i < 11; i++)
    {
        //Operation(i);//同步调用
        //BeginInvoke (<输入和输出变量>,AsyncCallBack,object asyncState)
        //i * 10：委托输入的参数
        //（result）：表示回调函数AsyncCallBack，就是异步执行完后，自动调用的方法
        //返回值：IAsyncResult -- 异步操作状态接口。封装了异步中执行的参数
        Operation.BeginInvoke(i * 10, (result) =>
        {
            Console.WriteLine($"第{result.AsyncState}个计算结果：{Operation.EndInvoke(result)}");
        }, i);
    }
    //EndInvoke()方法，通过IAsyncResult接口对象，在执行任务中，不断地去观察异步调用是否结束
    //这个方法知道异步调用方法的全部参数，所以异步调用完毕后，取出异步调用结果作为返回值
    //最后一个参数就是给回调函数AsyncState赋值，向回调传递参数
}
```

==提示：==.Net 5以上版本会报错**<u>Operation is not supported on this platform.</u>**

==原因：==	这个错误是因为在.NET 5及其以上版本中，`BeginInvoke`方法已经被标记为过时，不再支持使用。在.NET 5及其以上版本中，我们应该使用`Task.Run`方法或`Task.Factory.StartNew`方法来实现异步操作。

如果要在控制台应用程序中实现异步操作，可以将`Operation`委托改写为异步方法。

#### .Net 6及其以上版本

```c#
private static Random random = new Random();
//定义一个任务，基于委托实现求一个数的平方
private static async Task<int> OperationAsync(int num)
{
    await Task.Delay(random.Next(5) * 1000);//相当于低版本的Thread.Sleep(random.Next(5) * 1000);
    return num * num;
}
public static async Task<List<string>> moniAsync()
{
    List<string> text = new List<string>();
    for (int i = 1; i < 11; i++)
    {
        //Operation(i);//同步调用
        //BeginInvoke (<输入和输出变量>,AsyncCallBack,object asyncState)
        //i * 10：委托输入的参数
        //（result）：表示回调函数AsyncCallBack，就是异步执行完后，自动调用的方法
        //返回值：IAsyncResult -- 异步操作状态接口。封装了异步中执行的参数
        var result = await OperationAsync(i * 10);
        Console.WriteLine($"第{i}个计算结果：{result}");
        text.Add($"第{i}个计算结果：{result}");
    }
    return text;
}
```

`Task.Delay`和`Task.Run`都是.NET Framework中用于实现**异步操作**的方法，但它们的作用和用法不同。

`Task.Delay`方法用于在异步方法中等待一段时间后再继续执行。它的作用**类似于**`Thread.Sleep`方法，但不会**阻塞线程**。`Task.Delay`方法返回一个`Task`对象，表示**异步操作的状态**。在等待时间到达之后，异步操作就会完成，可以在`await`关键字后的代码中继续执行。

#### 异步编程总结

1. 异步编程是建立在委托的基础上实现的多线程方法.
2. 异步调用的每个方法都是独立的线程中进行的.因此异步编程就是多线程一种,可以说是一种简化的多线程.
3. 比较适合在后台耗费时间长,但是任务简单的情况.并且人物之间是独立的.
4. 如果后台要求访问共享资源,并且按照某些顺序执行,则异步不适合.应该采用多线程去完成.

### 2、Thread

**进程：**一个正在运行的程序就是一个进程。操作系统根据进程分配各种资源（内存.....）
**线程：**操作系统为了提高效率会将一个进程分成多个线程，并按照线程来分配CPU执行的时间。
**时间分配：**比如A进程10个线程，B进程2个线程，操作系统会按照12个线程来分配CPU时间，这样A进程有机会获得CPU的几率就大。
**线程特点：**在具有多个CPU的计算机中，可以并行执行。如果是单CPU,则会出现《假象》。
1-CPU A B C
**单线程：**只有一个线程的进程称为“单线程”进程。拥有多个线程的的进程称为多线程进程
**Thread类：**表示托管线程，每个Thread对象都代表这一个托管线程，每个托管线程都对应这一个函数。
**Thread类：**与操作系统真是的本地线程不是一一对应关系，它只是一个“逻辑线程”。
**ProcessThread类：**用于表示提作系统电直实的本地线程

#### **winform---demo1：**

```c#
//执行任务一 两个同时执行时时同步
private void button1_Click(object sender, EventArgs e)
{
    int num = 0;
    Thread thread = new Thread(() =>
    {
        for (int i = 1; i < 20; i++)
        {
            Console.WriteLine((num + i) + "");
            Thread.Sleep(500);
        }
    });
    thread.IsBackground = true;//设置为后台线程（通常要这样设置）
    thread.Start();
    //关于前台线程和后台线程：
    //一个程序如果开启的都是后台线程，则程序关闭的时候，后台线程也就自动全部退出。
    //一个程序如果有前台线程，必须在所有的前台线程都结束后，才能退出。
}
//执行任务二
private void button2_Click(object sender, EventArgs e)
{
    int num = 0;
    Thread thread = new Thread(() =>
    {
        for (int i = 1; i < 20; i++)
        {
            Console.WriteLine($"------------------{i}-----------------");
            Thread.Sleep(500);
        }
    });
    thread.IsBackground = true;//设置为后台线程（通常要这样设置）
    thread.Start();
}
```

#### **winform---demo2：**

```c#
private void button1_Click(object sender, EventArgs e)
{
    int num = 0;
    //开启线程
    Thread thread = new Thread(() =>
    {
        for (int i = 1; i < 20; i++)
        {
            num += i;
            //this.label1.Text = num.ToString();//不能直接跨线程访问控件
            if (this.label1.InvokeRequired)
            {
                this.label1.Invoke(new Action<string>(s =>
                {
                    this.label1.Text = s;
                }),num.ToString());
            }
            Thread.Sleep(300);
        }
    });
    thread.IsBackground = true;//设置为后台线程（通常要这样设置）
    thread.Start();
    //关于前台线程和后台线程：
    //一个程序如果开启的都是后台线程，则程序关闭的时候，后台线程也就自动全部退出。
    //一个程序如果有前台线程，必须在所有的前台线程都结束后，才能退出。
}

//执行任务二
private void button2_Click(object sender, EventArgs e)
{
    Thread thread = new Thread(() =>
    {
        this.label2.Invoke(new Action<string>(s =>
        {
            this.label2.Text = s;//将读取的控件值，在其它控件中显示出来
        }), this.textBox1.Text);
    });
    thread.IsBackground = true;//设置为后台线程（通常要这样设置）
    thread.Start();
}
```

#### **winform---demo3：**

```c#
//跨线程访问数据库，并在DGV中战术数据
private void button2_Click(object sender, EventArgs e)
{
    Thread thread = new Thread(() =>
    {
        DataSet ds = DBHelper.GetDataTable("select * from Users;select * from banner");
        DataTable dt1 = ds.Tables[0];
        DataTable dt2 = ds.Tables[1];
        Thread.Sleep(1000);
        //第一个数据源
        this.dataGridView1.Invoke(new Action<DataTable>(t =>
        {
            this.dataGridView1.DataSource = t;
        }), dt1);
        //第二个数据源
        this.dataGridView2.Invoke(new Action<DataTable>(t =>
        {
            this.dataGridView2.DataSource = t;
        }),dt2);
    });
    thread.IsBackground = true;//设置为后台线程（通常要这样设置）
    thread.Start();
}
```

**句柄：其实几句诗表示程序中某个对象，或者理解成这个对象的一个别名**

### 3、ThreadPool

#### 简单了解-demo

```c#
 static void Main()
 {
     //Application.EnableVisualStyles();
     //Application.SetCompatibleTextRenderingDefault(false);
     //Application.Run(new Form1());

     ThreadApp2();
 }
 static void ThreadApp2() {
     //使用线程池
     ThreadPool.QueueUserWorkItem(i => { Method1(); });
     //开启第二个线程
     ThreadPool.QueueUserWorkItem(i => { Method2(); });

     Console.WriteLine("主线程ID={0}", Thread.CurrentThread.ManagedThreadId);
     Console.ReadLine();

}

private static void Method1() {
    Console.WriteLine("任务1执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务1执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务1所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}

private static void Method2()
{
    Console.WriteLine("任务2执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务2执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务2所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}
```

### 4、Task

#### 微软推荐使用，功能比Thread强大-demo

```c#
static void Main()
{
    ThreadApp3();
}
static void ThreadApp3()
{
    //使用Task
    Task task1 = new Task(Method1);
    Task task2 = new Task(Method2);
    task1.Start();
    task2.Start();
    Console.WriteLine("主线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.ReadLine();
}

private static void Method1() {
    Console.WriteLine("任务1执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务1执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务1所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}

private static void Method2()
{
    Console.WriteLine("任务2执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务2执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务2所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}
```

### 5、TaskFactory

#### 代码示例-demo

```c#
static void Main()
{
    ThreadApp4();
}

static void ThreadApp4()
{
    //使用TaskFactory(类似于线程池)
    Task.Factory.StartNew(Method1);
    Task.Factory.StartNew(Method2);
    Console.WriteLine("主线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.ReadLine();

}

private static void Method1() {
    Console.WriteLine("任务1执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务1执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务1所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}

private static void Method2()
{
    Console.WriteLine("任务2执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务2执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务2所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}
```

### 6、Parallel

#### 比较简单-demo

```c#
static void Main()
{
    ThreadApp5();
}
static void ThreadApp5()
{
    Parallel.Invoke(Method1, Method2);
    Console.WriteLine("主线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.ReadLine();

}

private static void Method1() {
    Console.WriteLine("任务1执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务1执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务1所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}

private static void Method2()
{
    Console.WriteLine("任务2执行开始时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Thread.Sleep(3000);
    Console.WriteLine("任务2执行结束时间={0}", DateTime.Now.ToString("HH:mm:ss"));
    Console.WriteLine("任务2所用线程ID={0}", Thread.CurrentThread.ManagedThreadId);
    Console.WriteLine("-----------------");
}
```

