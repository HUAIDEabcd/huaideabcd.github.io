---
title: 委托
date: 2022-05-20 21:58:10
tags:
    委托,Expression
categories:
    C#
---

# 委托

- 委托的声明、实例化和调用
- 委托的作用和意义
- 委托的花样是扩展
- 俄罗斯套娃的本质



## 一、什么是委托

1. 形似于一个方法  修饰符  关键字：delegate  返回值   名称  参数
2. 可以声明在类的外部，也可以声明在类的内部



## 二、委托的本质——底层

1. 反编译——IL—SPY 
2. 委托在底层——有构造函数——有普通方法——委托的本质就是一个类，继承自[System.Runtime]System.MulticastDelegate特殊类
3. 如何使用一个类？  实例化，调用
4. 委托的实例化——需要参数，参数需要一个方法—需要一个和委托的参数和返回值完全一致的方法
5. 调用Incoke方法——就是去执行在委托实例化的时候，指定的方法



## 三、委托带来的好处

1. 委托就像是一个盒子，可以把一个方法包装起来，委托可以把方法当作参数来传递——方法的本质——执行的行为——执行的业务逻辑，委托可以把业务逻辑包装起来；委托又是一个类：类的实例，也可以单座参数来传递；可以使用委托把方法封装后，传递到任何地方





## 微软提供的两个委托

- Action：带有参数，没有返回值的委托；参数最多可以有16提供了一个用16个的版本
- Func：是一个一定有返回值的泛型委托，支持没有参数，也支持有参数，在泛型尖括号中，最后一个参数类型是返回值类型，前面的类型为参数的类型；参数最多支持也是16个
- 如果需要超过十六个参数的可以自己定义



```c#
	Action action = new Action(() => {});
		//参数
	Action<int> action1 = new Action<int>(i => {})



	Func<int> func = () => {return 23};
       //参数，返回值类型
	Func<int,string> func1 = s => {return s.ToString()};
	Func<int,string,string> func2 = (i,s) => {return s};

	//这两种委托就满足了所有的诉求，在以后开发过程中，就尽量使用这两种委托；就不需要自己再去定义委托，避免了定义很多个功能完全一样的委托；
```



## 多播委托

- 多播委托在实例化以后，可以通过+=给委托添加方法，形成一个方法链，在Invoker的时候，会按照+=的顺序依次执行；
- 同时也可以通过-=移除方法；从方法链中去掉方法；移除的方法是按照从上往下的顺序移除

```C#
	//声明委托
	public delegate void NoReturnWithPara(object? obj);
	
	//实例化委托
	NoReturnWithPara noReturnWith = new NoReturnWithPara(Show);
	
	//多播委托
	noReturnWith += Show;
	//加上一个对象里面的方法
	noReturnWith += new Student().Study;
	noReturnWith += s =>{
        Console.WriteLine($"this is lambada表达式。。。{s}");
    }
	//添加静态方法
	noReturnWith += StaticStudy;
	
	//减方法
	noReturnWith -= show;
	noReturnWith -= StaticStudy：
    noReturnWith -= new Student().Study;//移除不了，因为不同的实例在内存中是不同的引用；-= 如果不存在，也不影响
	noReturnWith -= s => {
        Console.WriteLine($"this is lambada表达式。。。{s}");
    }

	
```





# 表达式目录树Expression

```c#
	//平常写法
	var list = new List<People>();
	//委托
	Func<People,bool> func = p => p.id == 1;
	var resultlist = list.Where(func)
    //Func<TSource,bool> predicate
        
        
    //表达式目录树      //AsQueryable()按需查询提高效率
    var query = list.AsQueryable();
	//目录树
	Expression<Func<People,bool>> expression = u => u.id == 1;
	var querylist = query.Where(expression);

```



## Func &&  expression有什么区别

- 委托可以直接Invoke，Expression不能直接Invoke
- Expression可以通过Compile变成一个委托
- 表达式目录树只能有一行，不能有大括号

```c#
	func.Invoke(new People());//委托可以直接Invoke
	//expression.Invoke();//目录树不能直接Invoke
	var fun1 = expression.Compile();//Compile可以把expression变成一个委托
	fun1.Invoke(new People());//贬称委托后可以进行Invoke


	//表达式目录树也可以通过拉姆达表达式来
	Expression<Func<int,int,int>> exp = (m,n) => m*n + 2;



	//表达式目录树只能有一行
	Expression<Func<int,int,int>> exp1 = (m,n) =>m * n + 2;
	//这样不行会报错只能有一行
	Expression<Func<int,int,int>> exp1 = (m,n) =>{
        return m * n + 2;
    }
	
```

```c#
//三、表达式目录树的本质  为什么表达式目录树只能是一行呢？---委托本质是一个类，使用的时候是为了传递方法
            //1.表达式目录树展开后：有Body等属性，进一步展开；会分为左边，右边；是一个数据结构；可以有很多分支；符合我们人类的思维；像口语中对一个事物的描述；
            //2.二叉树
            //3.表达式目录树可以是无限长---因为是二叉树，二叉树可以无限的往下分支，分支越多，二叉树的最上面节点就更长
            {
                Func<Company, bool> func = c => c.Id.ToString() == "2";
                Expression<Func<Company, bool>> predicate = c => c.Id.ToString() == "2" && c.Name.Equals("朝夕教育") && c.CreateTime > DateTime.Now && c.CreatorId > 2 && c.LastModifierId > 3;

                //表达式目录树---一种查询条件：肯定要执行到数据库中去;   数据库其实只认识Sql语句；
                //1.把表达式目录树编程sql语句


            }
```

- 在查询的时候，就可以灵活的拼装查询条件
- 可以进行封装
  - 封装以后，只需要你把拼装的部分表达书目录树传递过来，然后我这里封装后，进行进一步的组合；
- 可以做到无限的拼装，查询的时候，条件无论是多少，我们都可以把条件拼装过来；



### ExpressionVisitor  

- ExpressionVisitor    是一个抽象类，内部有很多虚方法；专门用来解析各种表达式目录树
- 会有一个VIsit方法，这是解析表达式目录树的入口；
- VIsit  判断是什么类型的表达式目录树，进行调度，调度到更加专业的方法中去进行一步的解析；







![image-20220808092759606](https://gitee.com/be_lieve_oneself/demo1/raw/master/image-20220808092759606.png)





![image-20220808093652433](https://gitee.com/be_lieve_oneself/demo1/raw/master/image-20220808093652433.png)







![image-20220808094426374](https://gitee.com/be_lieve_oneself/demo1/raw/master/image-20220808094426374.png)