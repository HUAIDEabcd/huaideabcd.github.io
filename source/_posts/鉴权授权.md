---
title: 鉴权授权
date: 2022-05-20 21:58:10
tags:
    JWT
categories:
    C#
---

# 鉴权授权

**所谓鉴权授权，其实就是用户登录检测和权限检测一必备需求**

1. 建一个ASP.NET Core 项目 （VS2022+.NET6）
2. UseAuthentication +  AddAuthentication
3. UseAuthorization + AddAuthorization(还没写)
4. [Authorize] [AllowAnonymous]

## 理解持久化

从Http无状态 --- 到Cookie-Session ---- 到Token机制

**基本流程：**

1. 请求服务端拿到凭证
2. 客户端请求带上凭证
3. 服务端通过凭证来决定是否允许访问

![](https://gitee.com/be_lieve_oneself/demo1/raw/master/%E9%89%B4%E6%9D%83/4.png)

## 理解鉴权授权

**鉴权授权都是服务端做的事儿** ---- 工作就是做==凭证识别==和==权限检测==

- 鉴权 => **Authentication：**鉴别有没有登录，登录的是张三还是李四 ----- ==UseAuthentieation 配置Http管道==，保障请求进来了都要做鉴权操作 ----- ==AddAuthentication 配置如何鉴权==（凭证是怎么传递的 —— 凭证的格式 —— 基础的有效性加测 ——  没有登录怎么办、没有权限怎么办 ）
- 授权 => **Authorizatior：**判断下张三有没有权限访问这个资源 ---- 默认就是有正常用户即可访问，但是也可能会有各种==动态策略==



## 执行时机

**生命周期问题 ---- 理解** —— **ASP.NET Core 设计的亮点**

**先鉴权后授权** ----- 请求一是==路由==下，二是==Controller-view --==

**中间件顺序：**

1. **UseRouting —— 路由**
2. **UseAuthentication**
3. **UseAuthorization**
4. **MapControllerRoute(UseEndpoint) --- MVC流程**

 -----------------**最优顺序** -----------------

1. **路由匹配找到Action的特性**
2. **鉴权**
3. **授权**
4. **继续MVC**

## 鉴权理解

**鉴权就是检测凭证 --- 鉴别是某个用户 ---- 解析请求携带的用户信息**

1. **凭证位置：**怎么传递的凭证 -url地址，header，**authorize -- AuthenticationScheme**
2. **凭证格式：**加密/序列化 ---  ==**JWT**== 是2种，**Cookie --- AuthenticationScheme**
3. **信息有效性： **==**JWT**== 的属性检测
4. **鉴权后信息保存：**==**context.User**==
5. **特殊情况处理：**没登陆 - 没权限 - 其他

这些都是鉴权该做的



## 自定义鉴权

1. 凭证是自己拼装的，指定位置传递

2. 自定义一个鉴权 **handler** ，基于鉴权 **Scheme** 识别 --- **UrlToken**

3. 实现IAuthenticationHandler接口，核心逻辑理解

4. 启动时注入配置，AddScheme(方案)

5. 流程演练：

   http://localhost:5726/Auth/UrlToken?UrlToken=eleven-123456

​	证明了可以解析UrlToken且得到信息

​	http://localhost:5726/Auth/UrlTokenWithAuth?UrlToken=eleven-123456

​	==（证明已生效）==



## Policy演练

**Policy策略：**支持更灵活的**自定义策略**

使用更多种方式来表达**RequiredRole**

1. ```c#
   options.AddPolicy(AdminPolicy policyBuilder => policyBuilder.RequireRole(Admin ))
   ```

2. ```c#
   options.AddPolicy("AssertionStudentReason", policyBuilder => policyBuilder.RequireAssertion(context => context.User.HasClaim(c => c.Type =="Student") && context.User.Claims.First (c => c.Type.Equals("Student")).Value = "Reason"
   ```

   

## 代码演示

不关怎么样，诸如后



1. 新建一个.Net Core 6.0 的项目

   ![image-20230301095509713](https://gitee.com/be_lieve_oneself/demo1/raw/master/%E9%89%B4%E6%9D%83/image-20230301095509713.png)



### 通过Cookie完成鉴权操作

**打开==Program.cs==文件**

1. 在**app.UseAuthorization();**上面添加鉴权中间件；

   ```c#
   app.UseAuthentication();//认证 鉴权
   ```

2. 在**builder.Services.AddControllersWithViews();**下面添加注入代码；

   ```c#
   //通过cook完成鉴权操作
   builder.Services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)            .AddCookie(CookieAuthenticationDefaults.AuthenticationScheme, options =>
   {
       options.LoginPath = "/Home/Index"; //登录地址--- 没有登录就跳转
       options.AccessDeniedPath = "/Home/Index"; //权限地址--- 没有权限就跳转
   });
   
   //----------鉴权授权---------         
   app.UseAuthentication();//认证 鉴权
            
   app.UseAuthorization();//授权 ----- 默认就有的
   //----------鉴权授权----------
   ```

如何使用 —— **示范**：HomeController文件：

```c#
[Authorize()]//所有鉴权授权
    public class HomeController : Controller
    {
        private readonly ILogger<HomeController> _logger;

        public HomeController(ILogger<HomeController> logger)
        {
            _logger = logger;
        }

        [AllowAnonymous]//跳过授权
        public IActionResult Index()
        {
            return View();
        }

        
        public IActionResult Privacy()
        {
            return View();
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }
    }
```

需要在哪里授权就在哪里加 ==**[Authorize()]**== ，需要跳过授权就加 ==**[AllowAnonymous]**==



### 自定义鉴权

我们首先需要新建一个文件夹 -- ==Utilty== 添加一个类 -- **UrlTokenAuthenticationHandler** 里面我们需要封装一些方法：

```c#
using Microsoft.AspNetCore.Authentication;
using Newtonsoft.Json;
using System.Security.Claims;

namespace 鉴权授权1.Utility
{
    //鉴权处理器的接口：IAuthenticationHandler

    /// <summary>
    /// 鉴权Handler
    /// Program里面调用
    /// </summary>
    public class UrlTokenAuthenticationHandler : IAuthenticationHandler, IAuthenticationSignInHandler, IAuthenticationSignOutHandler
    {

        private AuthenticationScheme _AuthenticationScheme = null;//"UrltokenScheme"
        private HttpContext _HttpContext = null;
        /// <summary>
        /// 初始化，Provider传递进来的
        /// 像方法注入
        /// </summary>
        /// <param name="scheme"></param>
        /// <param name="context"></param>
        /// <returns></returns>
        public Task InitializeAsync(AuthenticationScheme scheme, HttpContext context)
        {
            Console.WriteLine($"This is {nameof(UrlTokenAuthenticationHandler)}.InitializeAsync ");
            this._AuthenticationScheme = scheme;
            this._HttpContext = context;
            return Task.CompletedTask;
        }

        /// <summary>
        /// 核心方法，完成凭证解析
        /// </summary>
        /// <returns></returns>
        public Task<AuthenticateResult> AuthenticateAsync()
        {
            Console.WriteLine($"This is {nameof(UrlTokenAuthenticationHandler)}.AuthenticateAsync");
            string userInfo = this._HttpContext.Request.Query["UrlToken"];//信息从哪里读
            if (string.IsNullOrWhiteSpace(userInfo))
            {
                return Task.FromResult<AuthenticateResult>(AuthenticateResult.NoResult());
            }
            else if("zhanglei-123456".Equals(userInfo))//没去数据库
            {
                //把信息传递下去 -- 让授权去使用 -- 写入context.User
                var claimIdentity = new ClaimsIdentity("Custom");
                claimIdentity.AddClaim(new Claim(ClaimTypes.Name, "ZhangLei"));
                claimIdentity.AddClaim(new Claim(ClaimTypes.Role, "Admin"));
                claimIdentity.AddClaim(new Claim(ClaimTypes.Email, "zl18431059121@163.com"));
                claimIdentity.AddClaim(new Claim(ClaimTypes.Country, "China"));
                claimIdentity.AddClaim(new Claim(ClaimTypes.DateOfBirth, "2001"));//识别出来的用户信息
                ClaimsPrincipal claimsPrincipal = new ClaimsPrincipal(claimIdentity);//信息拼装和传递
                return Task.FromResult<AuthenticateResult>(AuthenticateResult
                    .Success(new AuthenticationTicket(claimsPrincipal, null, _AuthenticationScheme.Name)));
            }
            else
            {
                return Task.FromResult<AuthenticateResult>(AuthenticateResult.Fail($"UrlToken is wrong:{userInfo}"));
            }
        }

        /// <summary>
        /// 未登录
        /// </summary>
        /// <param name="properties"></param>
        /// <returns></returns>
        public Task ChallengeAsync(AuthenticationProperties properties)
        {
            Console.WriteLine($"This is {nameof(UrlTokenAuthenticationHandler)}.ChallengeAsync");
            string redirectUri ="/Auth/Index";
            this._HttpContext.Response.Redirect(redirectUri);
            return Task.CompletedTask;
        }


        /// <summary>
        /// 未授权，无权限
        /// </summary>
        /// <param name="properties"></param>
        /// <returns></returns>
        public Task ForbidAsync(AuthenticationProperties properties)
        {
            Console.WriteLine($"This is {nameof(UrlTokenAuthenticationHandler)}.ForbidAsync");
            this._HttpContext.Response.StatusCode = 403;
            return Task.CompletedTask;
        }

        /// <summary>
        /// SignInAsync和SignOutAsync使用了独立的定义接口，
        ///因为在现代架构中，通常会提供一个统一的认证中心，负责证书的颁发及销毁（登入和登出），
        ///而其它服务只用来验证证书，并用不到SingIn/Sing0ut。
        /// </summary>
        /// <param name="user"></param>
        /// <param name="properties"></param>
        /// <returns></returns>
        public Task SignInAsync(ClaimsPrincipal user, AuthenticationProperties properties)
        {
            var ticket = new AuthenticationTicket(user, properties, this._AuthenticationScheme.Name);
            this._HttpContext.Response.Cookies.Append("UrlTokenCookie", 
                JsonConvert.SerializeObject(ticket.Principal.Claims));
            //把一些信息再写入到前端cookie,客户端请求时，从coookie读取UrlTokenCookie信息，放到url上
            return Task.CompletedTask;
        }


        /// <summary>
        /// 退出
        /// </summary>
        /// <param name="properties"></param>
        /// <returns></returns>
        public Task SignOutAsync(AuthenticationProperties properties)
        {
            this._HttpContext.Response.Cookies.Delete("UrlTokenCookie");
            return Task.CompletedTask;
        }

        
        public class UrlTokenAuthenticationDefaults
        {
            /// <summary>
            /// 提供固定名称
            /// </summary>
            public const string AuthenticationScheme = "UrlTokenScheme";
        }

    }
}

```

再这个里面我们需要用到一个NutGet包，我们需要安装一下 --- **Newtonsoft.Json** --- 这个包里面的方法我们在上面的类中是需要用到的。

里面的**核心方法**是我们需要添加凭证的，我们需要，根据自己的所需要的数据凭证进行自定义；



**打开==Program.cs==文件**

把我们刚才写的哪个类库给注入进来：

```c#
#region 自定义鉴权
//参数通过url地址传输
//调用Utility 里面的 UrlTokenAuthenticationHandler
builder.Services.AddAuthentication(options =>
{
     //定了一个Scheme方案，Key(scheme名字)-value
     options.AddScheme<UrlTokenAuthenticationHandler>
     (UrlTokenAuthenticationDefaults.AuthenticationScheme, "UrlTokenScheme-Demo");
     options.DefaultAuthenticateScheme = UrlTokenAuthenticationDefaults.AuthenticationScheme;//默认Scheme

     //都☞给AuthenticationScheme
     options.DefaultChallengeScheme = UrlTokenAuthenticationDefaults.AuthenticationScheme;
     options.DefaultSignInScheme = UrlTokenAuthenticationDefaults.AuthenticationScheme;//登录
     options.DefaultForbidScheme = UrlTokenAuthenticationDefaults.AuthenticationScheme;//权限
     options.DefaultSignOutScheme = UrlTokenAuthenticationDefaults.AuthenticationScheme;//退出
});
#endregion
//----------鉴权授权---------         
app.UseAuthentication();//认证 鉴权
         
app.UseAuthorization();//授权 ----- 默认就有的
//----------鉴权授权----------
```



**新建一个控制器 -- Auth  来进行测试：**

里面写方法进行**判断传过来的是不是有权限**访问我们的页面：

```C#
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Text;
using static 鉴权授权1.Utility.UrlTokenAuthenticationHandler;

namespace 鉴权授权1.Controllers
{
    public class AuthController : Controller
    {
        public IActionResult Index()
        {
            return View();
        }

        #region UrlToken

        /// <summary>
        /// 鉴权
        /// https://localhost:5726/Auth/Urltoken?UrlToken=zhanglei-123456
        /// </summary>
        /// <returns></returns>
        public async Task<IActionResult> UrlToken()
        {
            var result = await base.HttpContext.AuthenticateAsync
                (UrlTokenAuthenticationDefaults.AuthenticationScheme);
            if (result?.Principal == null)
            {
                return new JsonResult(new
                {
                    Result = false,
                    Message = $"认证失败，用户未登录"
                });
            }
            else
            {
                base.HttpContext.User = result.Principal;
                StringBuilder sb = new StringBuilder();
                foreach (var item in base.HttpContext.User.Identities.First().Claims)
                {
                    Console.WriteLine($"InfoGet {item.Type} : {item.Value}");
                    sb.Append($"{item.Type} : {item.Value}");
                }
                return new JsonResult(new
                {
                    Result = true,
                    Message = $"认证成功，用户已登录"
                });
            }
        }

        #endregion
    }
}

```

访问某个页面的时候后面加上这个方法并且传参数https://localhost:5726/Auth/Urltoken?UrlToken=zhanglei-123456

### 自定义鉴权（可省略版）

**打开==Program.cs==文件**



```c#
//builder.Services..AddAuthorization(); //可以不要，因为包含在AddControllersWithViews
builder.Services.AddAuthorization(options =>
{
   options.AddPolicy("AdminPolicy", policyBuilder => policyBuilder.RequireRole("Admin"));

   options.AddPolicy("AssertionAdminPolicy",policyBuilder =>
   policyBuilder.RequireAssertion(context =>
   context.User.HasClaim(c => c.Type == ClaimTypes.Role)
   && context.User.Claims.First(c => c.Type.Equals(ClaimTypes.Role)).Value == "Admin"
   )//Claim的Role是User
   );
   options.AddPolicy("AssertionStudentReason", policyBuilder =>
   policyBuilder.RequireAssertion(context =>
   context.User.HasClaim(c => c.Type == "Student")
   && context.User.Claims.First(c => c.Type.Equals("Student")).Value == "Reason"
   )//Claim的Role是User
   );
 });           
//----------鉴权授权---------         
app.UseAuthentication();//认证 鉴权
         
app.UseAuthorization();//授权 ----- 默认就有的
//----------鉴权授权----------
```

